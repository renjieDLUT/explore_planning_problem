[toc]

#  类与对象

## 类的定义

1. 数据成员+方法；

2. 访问控制；

3. this指针；

4. 解引用运算符（*）、成员访问运算符（.）、指针运算符。

5. 对象的生命周期。理解对象什么时候被创建、赋值和销毁。

6. 构造函数初始化器（ctor_initializer）。某些数据成员必须在ctor_initializer中或类内进行初始化（const、引用、没有默认构造函数的对象数据成员）

   ```cpp
   class Foo{
   public:
       Foo(int num, string s):num_(num),s_(s){} //ctor_initializer
   private:
       int num_;
       string s_;
   };
   ```

7. 编译器自动生成的构造函数规则

   | 用户自定义                 | 编译器                     |
   | -------------------------- | -------------------------- |
   | 只要用户定义了任何构造函数 | 不会生成默认构造函数       |
   | 用户没有定义复制构造函数   | 编译器自动生成复制构造函数 |

   

8. 显示默认（default）、显示删除（delete）

9. 数据成员的初始化顺序：在类定义中出现的顺序，和ctor_initializer中的顺序无关。

10. 在构造函数体内对数据成员赋值时，调用的时赋值运算符而不是复制构造函数。

## 构造函数

 1. 无参构造。默认构造函数。在堆栈中创建对象时，调用无参构造函数不需要使用圆括号（*与函数声明产生歧义*）。

    ```cpp
    class Foo{
    public:
        Foo()=default;
    };
    
    void function(){
        Foo obj; //调用无参构造函数，不需要加圆括号
    }
    ```

    

 2. 委托构造。允许构造函数调用同一个类的其他构造函数，这个调用不能放在函数体内，必须放在构造函数初始化器中（ctor_initializer）;

 3. 有参构造

    - 初始化列表构造函数。#include<initializer_list>

      ```cpp
      std::vector<int> a={1,2,3};
      ```

      

 4. 复制构造。

    ```cpp
    class Foo{
    public:
        Foo();
        Foo(const Foo& other);
    };
    ```

    

    - 参数必须是const& ，

 5. 移动构造

## 析构函数

## 重载运算符

## 友元

允许类将其他类、其他类的成员函数、普通函数声明为友元（**friend**）。友元违反封装的原则，将类的内部暴露给其他类和函数，只有在特定情况下才应该使用。

## 对象的动态内存分配

1. 创建对象
2. 使用析构函数释放内存，析构函数**隐式标记noexcept**(noexcept标记函数，指示函数不会抛出异常)。最好让析构函数只释放内存，清理资源。
3. 处理复制和赋值。
   - 默认复制构造函数和赋值运算符，只是浅拷贝。容易出现悬挂指针、内存泄露问题。
   - 无论什么时候，在类中动态分配内存后，都应该自定义复制构造函数和复制运算符，以提供深拷贝。
4. 使用移动语义处理移动。对象的移动语义需要实现移动构造函数（move constructor）和移动赋值运算符(move assignment operator)。如果源对象是操作结束后被销毁的临时对象，编译器就会使用这两方法。
   - 右值引用的目的是在涉及临时对象时提供可选用的特定函数。由于临时对象会被销毁，通过右值引用，某些涉及复制大量值的操作可通过简单地复制指向这些值的指针来实现。
   - 右值引用参数（&&）不会和左值绑定。std::move()实现将左值转化为右值。
   - **右值引用参数（&&）本身是个左值**。
   - 实现移动语义。
   - 无自定义的复制构造函数、复制赋值运算符、移动赋值运算符和析构函数，编译器才会自动生成默认的移动构造函数。
   - 无自定义的复制构造函数、移动构造函数、复制赋值运算符和析构函数，编译器才会自动生成默认的移动赋值运算符。
   - “5规则”：如果类中动态分配了内存，应当实现复制构造函数、移动构造函数、复制赋值运算符、移动赋值运算符和析构函数。
## 不同的数据成员类型

1. 常量数据成员
   - 类内初始化，或则ctor-initializer中初始化。
   - 无法为具有常量数据成员的类提供复制运算符；
2. 静态数据成员
   - 关键字static
   - 在类定义中声明，源文件中为其分配内存；
   - c++17，可将静态数据成员声明为inline，不必在源文件中为他们分配空间。
3. 静态常量数据成员
   - 可在类定义中定义和初始化；
4. 引用数据成员
   - 必须在ctor-initializer中赋值；
   - 复制构造函数必须初始化这个引用成员
   - 初始化一个对象后，不能改变其引用的对象，因此不能在赋值运算符中对引用赋值，所以不能为具有引用数据成员的类提供赋值运算符；
5. 常量引用数据成员
   - 引用常量数据成员只能调用该成员对象的const方法。
## 嵌套类

嵌套类有权访问外围类的private和protected成员，外围类却只能访问嵌套类的public成员；

## 运算符重载

对象经常需要执行操作，如相加、比较、将对象输入文件、从文件读取。

1. 运算符重载是函数重载的一种形式，函数重载对函数返回类型没有要求；

2. 赋值运算符：通常通过“复制+交换"方式实现。

3. 隐式转换。

4. 类内的运算符重载不具有互换性，全局运算符重载具有互换性

5. 不更改运算符优先级；

6. 重载简写算术运算符。简写算术运算符会改变运算符左边的对象，而不是创建一个对象。而且生成的结果是对被修改对象的引用。简写算法运算符左边总要有个对象，因此应该将其作为方法而不是全局函数；

## 接口与实现分离（私有实现习语）

   将接口与实现分离后，会大幅缩减改变实现类后的构建编译时间。

另一种方法是使用抽象接口以及实现该接口的实现类。

## 继承

### 纯虚方法和抽象基类

1. 纯虚方法：在类定义时显示说明该方法不需要定义。
2. 抽象基类：具有至少一个纯虚方法的类叫着抽象基类。这个类没有实例。如果某个类包含一个或多个纯虚方法，就无法构建这种类型的对象。
3. 纯虚方法形式：在声明方法后紧接着=0；
4. 修改重写方法的特征：
   - 修改方法的返回类型；如果原始的返回类型是某个类的指针或引用，重写的方法可将返回类型改为派生类的指针或引用。这种类型称为**协变返回类型**
   - 修改方法的参数

 5. 继承的构造函数：

    - 形式：在派生类中使用using语句；

    - 会继承除默认构造函数外的其他全部构造函数，不能只是继承基类构造函数的一个子集；

    - 多重继承有关，如果一个基类的某个构造函数与另一个基类的构造函数具有相同的参数列表，就不可能从基类继承该构造函数，因为这样会产生歧义。

    - 当重写了基类中的某个方法，编译器隐藏基类中所有同名方法。

# 灵活而奇特的c++

### 引用

### const

### static

1. 静态数据成员和方法
2. 静态内部链接
    - 每个源文件都可成功编译，但链接时失败，因为f()函数具有内部链接；
    - 将static用于内部链接的另一种方式是使用匿名空间；可将变量或函数封装到一个没有名字的名称空间，而不是static
    - 在同一源文件中，可在声明匿名名称空间之后的任何位置访问名称空间中的项，但不能在其他源文件中访问。
    - 要获取内部链接，建议使用匿名名称空间，而不要使用static关键字
    - extern，编译器将这句语句当做声明而不是定义。对于变量而言，这意味着编译器不会为这个变量分配空间。必须为这个变量提供单独的、不适用extern关键字的定义行；

```cpp
static void f();
void f(){
    cout<<"hello";
}
```

```cpp
namespace{
    void f();
    void f(){
        coust<<"hello";
    }
}
```

3. 函数中的静态变量
   - 创建离开和进入作用域时都可保留值的局部变量；就像只能在函数内部方位的全局变量；
   - 场景：“记住”某个函数是否执行了特定的初始化操作；
   - 避免使用单独的静态变量，为了维持状态可以改用对象；
   - 

4. 非局部变量的初始化顺序
   - 程序中所有的全局变量和类的静态数据成员都会在main函数开始之前初始化；
   - 给定源文件中的变量以在源文件中出现的顺序初始化。
   - 不同源文件中非局部变量的初始化顺序是不确定的；

5. 非局部变量的销毁顺序
   - 按初始化的逆序进行销毁；
   - 不同源文件中非局部变量的初始化顺序是不确定的，所有销毁顺序不确定；
   - 

6. 类型和类型别名

   - 类型别名。为现有的类型声明提供新名称；

     ```cpp
     using IntPtr = int*;
     ```

     

   - 函数指针的类型别名.

     ```cpp
     using MatchFunction = bool(*)(int,int);  //指向具有两个int参数并返回布尔值的任何函数
     ```

     在c++中函数指针并不常见（被virtual关键字替代）

   - 方法和数据成员的指针的类型别名

   - typedef

     

### 类型转换

	- const_cast ：删除const特性；
	- static_cast：不执行运行期间的类型检测；
	- dynamic_cast：具有运行时检测功能的更安全的类型转换。转换指针或引用。在运行时检测底层对象的类型对象；如果类型转换没有意义，dynamic_cast将返回一个空指针；运行时类型信息存储在对象的虚表中。因此，要使用dynamic_cast，类至少有一个虚方法；
	- reinterpret_cast：将某种类型的指针转换（或引用）转换为其他无关类型的指针（或引用）

### 作用域解析

1. 当试图访问某个变量、函数或类时，首先在最近的作用域内查找这个名称，然后查找相邻的作用域，以此类推，直到全局作用域。任何不在名称空间、函数、花括号界定的块和类中的名称都被认为在全局作用域内，如果在全局作用域内找不到名称，编译器会给出未定义符号错误；

### 特性（attribute）

在源代码中添加可选信息的一种机制。

1. [[noreturn]]
2. [[deprecated]]：标记某个对象为废弃
3. [[fallthrough]]：switch语句中
4. [[nodiscard]]：
5. [[maybe_unused]]：



## 用户定义的字面量

1. 标准字面量：
   - 字符 ‘a'
   - 字符串 “hello”
   - 浮点数 3.14f
   - 十六进制 0xabc

c++11允许定义自己的字面量。用户定义字面量必须应该以下划线开头。

字面量运算符（literal operators）。生模式、熟模式

```cpp
std::complex<long double> operator""_i(long doule d){
    return std::complex<long double>(0,d);
}

std::complex<long double> c1=9.64_i;
auto c2=1.23_i;
```

 - 熟模式字面量运算符。
   - 一个参数（unsigned long long、long double、char、）
   - 二个参数(一个是字符数组，二个是字符数组的长度)
 - 生模式字面量运算符

标准的用户定义字面量

## 头文件

1. 避免多次包含同一个文件。文件保护机制
2. 循环引用
3. 

### 变长参数列表



# 模板

### 类模板

### 编译器处理模板的原理

1. 编译器遇到模板方法定义时，会进行语法检查，但是并不编译模板；
2. 选择性实例化：编译器总为泛型类的所有虚方法生成代码。但对于非虚方法，编译器只会为那些实际调用的非虚方法生成代码；

### 模板参数

1. 非类型的模板参数
2. 类型参数

### 方法模板

c++允许模板化类中的单个方法，这些方法可以在类模板中，也可以在非模板化的类中。在编写模板化的类方法时，实际在为很多不同的类型编写很多不同版本的方法；

不同用方法模板编写虚方法和析构函数；

```cpp
template <typename T>
class Grid{
public:
    
    template <typename E>
    Grid(const Grid<E>& src);//这个类在类型T上被模板化，这个复制构造函数又在另一个不同的类型E上被模板化。
    
    template<typename E>
    Grid<T>& operator=(const Grid<E>& src);
    
    void swap(Grid& other) noexcept;
private:
    std::optional<T> mCells[10][10];
};


template <typpename T>
template <typename E>
Grid<T>::Grid(const Grid<E>& src){
    ...
}

```

通过这种双重模板化可将一种类型的grid复制到另一种类型的grid。必须将声明类模板的哪一行放在成员模板的那一行声明的前面。

### 类模板的特例化

### 模板的类型推导

1. 类型推导可分成两大类：模板类型不是引用也不是指针的模板；引用和指针模板；
2. 对于类型不是引用也不是指针的模板，函数参数传值不影响原值，无论实际传入的参数是普通变量、常量还是引用，最终都退化为不带任何修饰的原始类型；
3. 引用和指针模板：

# I/O流

## 缓冲和非缓冲

1. 缓冲的流不是立即将数据送到目的地，而是缓冲输入的数据，然后以块方式发送；
2. 非缓冲的流则立即将数据发送到目的地。
3. 缓冲的目的通常是提升性能。
4. flush（）方法刷新缓冲区，强制要求缓冲的流将其当前所有的缓冲数据发送到目的地
5. 所有输入流都有一个关联的来源，所有输出流都有一个关联目的地。

### 流的来源和目的地

1. 流的概念可应用于任何接收数据和发送数据的对象。
2. 在c++中，流可使用3个公共的来源和目的地：控制台、文件和字符串；

### seek()和tell()

1. seek()方法允许在输入流和输出流中移动到任意位置
2. tell()方法查询流的当前位置；

### 将流链接在一起

任何输入流和输出流之间都可以建立链接，从而实现“访问时刷新”的行为。当输入流请求数据时，链接的输出流自动刷新

```cpp
ifstream inFile("input.txt");
ofstream outFile("output.txt");
inFile.tie(&outFile);

outFile<<"hello";
string nextToken;
inFile>>nextToken;
```

也可将一个输出流链接到另一个输出流；

### 双向I/O

# std::move()原理

```cpp
template<typename T>
typename remove_reference<T>::type&& move(T&& t){
    return static_cast<typename remove_reference<T>::type&&>(t);
}

template<typename T>
struct remove_reference{
    typedef T type;
};

template<typename T>
struct remove_reference<T &>{
    typedef T type;
};

template<typename T>
struct remove_reference<T &&>{
    typedef T type;
};
```

1. 通用引用

   ```cpp
   template<typename T>
   void Foo(T&& value);
   ```

   - 如果实参为左值，那么T&&为左值引用；
   - 如果实参为右值，那么T&&为右边引用；

2. 模板的类型推导

3. move的返回类型

4. 引用折叠

5. 类型成员

# 运算符重载

C++运算符的概念十分广泛，包括算术运算符：+、-、*、/、

逻辑运算符：<、>、...；数组索引[]、函数调用（）、类型转换以及内存分配和内存释放。

通过运算符重载来改变语言运算符对自定义类的行为。

1. **重载运算符的原因**：
   - 为了让自定义类的行为和内建类型一样。自定义类的行为越接近内建类型，就越便于客户使用；
   - 为了获得对程序行为更大的控制权；

2. **运算符重载的限制**

   - 不能添加新的运算符

   - 有少数运算符不能重载；

   - arity描述了运算符关联的参数或操作数的数量

   - 不能修改运算符的优先级

   - 不能对内建类型重定义运算符。运算符必须是类中的一个方法，或则全局重载运算符函数至少有一个参数必须是用户定义的类型；

     

3. **选择**
   - 方法还是全局函数（通常是类的友元）？
     - 必须为方法的运算符 ，例如：operator=、operator[]、operator()、operator type()
     - 必须为全局函数的运算符，如果运行运算符左侧的变量是除了自定义的类之外的任何类型，那么必须将这个运算符定位为全局函数。例如：operator<<、operator>>、可交换的运算符（+、-）

### 重载函数调用运算符

如果在自定义的类中编写了一个operator()，那么这个类的对象就可以当成函数指针使用。包含函数调用运算符的类对象称为函数对象，或仿函数（functor）.

函数对象可以伪装成函数指针，可将这些函数对象当成回调函数传给其他函数。

可实现接收多个索引的.(operator[]不能实现多个索引)；

### 重载解引用运算符

可实现类对象行为和指针一致。主要用途是实现智能指针；

1. operator*

2. operator->

   

### 类型转换运算符

没有返回类型，返回类型是通过运算符名称确定的；

```cpp
operator int()const;
operator std::string()const;
```



# 其他



1. noexcept 标记;

1. 在构造函数中抛出异常时，不会调用析构函数；

1. 前置声明的优势：可缩短编译和链接时间；

1. explicit标记，禁止有参构造函数（只有一个参数的构造函数）隐式类型转换。

1. 使用头文件的原因，便于维护原型的副本；

1. **通用引用**。auto&& 或则模板类型T&&

   ```CPP
   auto &&ref=5;
   
   int a=1;
   auto &&ref1=a;
   
   template<typename T>
   void Foo(T&& t);
   ```

   